* Array and Hashing

** Group Anagrams

Anagrams are strings with the same frequency of characters

For example,
/pots/, and /stop/ are anagrams since:

| char | frequency |
|------+-----------|
| p    |         1 |
| o    |         1 |
| t    |         1 |
| s    |         1 |


We can use that definition to solve the problem. The key 

*** Sorting and Hashing
Create a dictionary where the key is the sorted string and a value of a list of strings

#+begin_src python
  groups = defaultdict(list)
#+end_src

~defaultdict(list)~ prevents Python from complaining about a non-existent key. This also sets our value type to ~list~

Loop through each string and sort it

#+begin_src python
  for s in strs:
      sorted_str = ''.join(sorted(s))
#+end_src

We do ~''.join(sorted(s))~ since ~sorted(s)~ returns an array of characters of the sorted string and we want a string

We store the strings that have a sorted value in our dictionary, which may or may not correspond to a key in our dictionary.

#+begin_src python
              groups[sorted_str].append(s)
        return list(groups.values())
#+end_src

*** Full Code

#+begin_src python :results output
from collections import defaultdict
from typing import Counter, List
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        groups = defaultdict(list)
        for s in strs:
            sorted_str = ''.join(sorted(s))
            groups[sorted_str].append(s)
        return list(groups.values())
            
print(Solution().groupAnagrams(strs=["act","pots","tops","cat","stop","hat"]))

#+end_src

#+RESULTS:
: [['act', 'cat'], ['pots', 'tops', 'stop'], ['hat']]

** Top K Frequent Elements

#+begin_quote
I was able to solve this issue without looking up the solution but it was slow, with a runtime of $O(N \cdot K)$ but I'll include my naive attempt anyway
#+end_quote

*** Naive attempt

#+begin_src python
from typing import Counter, List
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        myHash = Counter(nums)
        myRes = []
        max_freq = 0
        for i in range(k):
            max_freq = max(myHash, key=myHash.get)
            myRes.append(max_freq)
            del myHash[max_freq]
            print(myHash)
        return myRes  
#+end_src

My intuition tells me I have to use a dictionary to get count the number of elements.
I loop ~k~ times where I get the key with the maximum value, append it to an array and delete the key, similar to a max queue but slower.

I had to share this Python one-liner I found in the leetcode solutions discussion because it made me laugh

#+begin_src python
  class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        return [x for x, y in collections.Counter(nums).most_common(k)]
#+end_src

*** Heap 

Just $O(1)$ for these cases
#+begin_src python
  if len(nums) == k:
   return nums
#+end_src

Create a dictionary to store the value and its frequency

Python's ~heapq~ module has the ~nlargest~ to cut out the work that we have to do
- Passing ~myHash.get~ to ~nlargest~ key arg applies the heap property on the dictionary keys based on its respective value

#+begin_src python
  myHash = Counter(nums)
  return hq.nlargest(k, myHash.keys(), key = myHash.get)
#+end_src


**** Full Code
#+begin_src python
from typing import Counter, List
import heapq as hq
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        if len(nums) == k:
           return nums
        myHash = Counter(nums)
        return hq.nlargest(k, myHash.keys(), key = myHash.get)
        
print(Solution().topKFrequent([1,1,1,2,2,3], k = 2))

#+end_src

** Encode and Decode Strings

#+begin_quote
Seemed too simple, but wasn't 100% sure I understood the problem, so I used all of the hints provided.
Hint 3 pratically told you what to do.
#+end_quote
*** Encoding

Encode the string by prefixing each string in the list with the length of the current string and some non alpha-numeric character that acts as the separator.
We return an amalgation of all the encoded strings.

#+begin_src python
    def encode(self, strs: List[str]) -> str:
        separator = "#"
        for i, s in enumerate(strs):
            strs[i] = f"{len(s)}{separator}{s}"

        return ''.join(strs)  
#+end_src

*** Decoding

Decode by reading the number until you reach the non alphanumeric separator. We store this as ~str_len~.
We use this number to get the words in index ~i + 1~ to ~i + 1 + num_len~ of the string and store it in our ~res~ array

#+begin_src python
def decode(self, s: str):
    str_len = ''
    num_len = 0
    res = []
    i = 0

    while i < len(s):
        if not s[i].isalnum():
            num_len = int(str_len)
            res.append(s[i + 1: i + 1 + num_len])
            i += num_len + 1
            str_len = ''
            num_len = 0
            continue
        str_len += s[i]
        i += 1

    return res
  
#+end_src


**** Full Code
#+begin_src python
  def encode(self, strs: List[str]) -> str:
      separator = "#"
      for i, s in enumerate(strs):
          strs[i] = f"{len(s)}{separator}{s}"

      return ''.join(strs)

  def decode(self, s: str):
      str_len = ''
      num_len = 0
      res = []
      i = 0

      while i < len(s):
          if not s[i].isalnum():
              num_len = int(str_len)
              res.append(s[i + 1: i + 1 + num_len])
              i += num_len + 1
              str_len = ''
              num_len = 0
              continue
          str_len += s[i]
          i += 1

      return res

#+end_src

