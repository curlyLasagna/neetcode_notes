* Array and Hashing

** Group Anagrams

Anagrams are strings with the same frequency of characters

For example,
/pots/, and /stop/ are anagrams since:

| char | frequency |
|------+-----------|
| p    |         1 |
| o    |         1 |
| t    |         1 |
| s    |         1 |


We can use that definition to solve the problem. The key 

*** Sorting and Hashing
Create a dictionary where the key is the sorted string and a value of a list of strings

#+begin_src python
  groups = defaultdict(list)
#+end_src

~defaultdict(list)~ prevents Python from complaining about a non-existent key. This also sets our value type to ~list~

Loop through each string and sort it

#+begin_src python
  for s in strs:
      sorted_str = ''.join(sorted(s))
#+end_src

We do ~''.join(sorted(s))~ since ~sorted(s)~ returns an array of characters of the sorted string and we want a string

We store the strings that have a sorted value in our dictionary, which may or may not correspond to a key in our dictionary.

#+begin_src python
              groups[sorted_str].append(s)
        return list(groups.values())
#+end_src

*** Full Code

#+begin_src python :results output
from collections import defaultdict
from typing import Counter, List
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        groups = defaultdict(list)
        for s in strs:
            sorted_str = ''.join(sorted(s))
            groups[sorted_str].append(s)
        return list(groups.values())
            
print(Solution().groupAnagrams(strs=["act","pots","tops","cat","stop","hat"]))

#+end_src

#+RESULTS:
: [['act', 'cat'], ['pots', 'tops', 'stop'], ['hat']]

** Top K Frequent Elements

#+begin_quote
I was able to solve this issue without looking up the solution but it was slow, with a runtime of $O(N \times K)$ but I'll include my naive attempt anyway
#+end_quote

*** Naive attempt

#+begin_src python
from typing import Counter, List
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        myHash = Counter(nums)
        myRes = []
        max_freq = 0
        for i in range(k):
            max_freq = max(myHash, key=myHash.get)
            myRes.append(max_freq)
            del myHash[max_freq]
            print(myHash)
        return myRes  
#+end_src

My intuition tells me I have to use a dictionary to get count the number of elements.
I loop ~k~ times where I get the key with the maximum value, append it to an array and delete the key, similar to a max queue but slower.

I had to share this Python one-liner I found in the leetcode solutions discussion because it made me laugh
#+begin_src python
  class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        return [x for x, y in collections.Counter(nums).most_common(k)]
#+end_src

